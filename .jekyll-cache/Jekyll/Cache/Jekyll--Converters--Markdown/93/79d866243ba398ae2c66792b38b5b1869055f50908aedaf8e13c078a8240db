I"C<p>Unpacking simple protections of common confuserex mods and other open source obfuscators. This write up was made for beginners, so if you are an experienced reverse engineer its probably not for you. Basic knowledge of C# and CIL is assumed. Keep in mind that the concepts and code shown are my approach, it can be done in different ways for example using emulation.</p>

<h3 id="contents">Contents:</h3>
<ol>
  <li>Getting started</li>
  <li>Deconstructing protections</li>
  <li>Credits</li>
</ol>

<h2 id="1-getting-started">1. Getting started</h2>
<p>
I got the idea of writing a custom unpacker to solve mutations/protections that could not be solved by de4dot after coming across more &amp; more ConfuserEx modifications using "custom" protections that could not be unpacked by de4dot, an example would be using sizeof() for integer mutations. Those are quickly removed but doing it manually is quite time wasting. So I decided to write a tool for it.
</p>
<p>
I chose AsmResolver as an assembly editing library. I started out by taking a look at the protections that I wanted to fix. To remove a protection we will first need to understand how the protection works. In my case the source code of most of the protections themselves was available in quite a few public ConfuserEx forks. But even if the source is not available we can determine how a protection works by decompiling a sample.
</p>

<h2 id="20-deconstructing-sizeof-mutations">2.0 Deconstructing: Sizeof Mutations</h2>

<p>A very common example are <code class="language-plaintext highlighter-rouge">sizeof()</code> mutations found in numerous public ConfuserEx forks. The most basic version looks somewhat like this:</p>

<p>Lets say our original code looks like this:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">256</span>
</code></pre></div></div>

<p>Now we run it through an obfuscator using <code class="language-plaintext highlighter-rouge">sizeof()</code> mutations, the result could look like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">260</span> <span class="p">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<p>The simple variable has been converted into an expression, <code class="language-plaintext highlighter-rouge">sizeof(int)</code> will return a value of 4 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof">(sizeof msdn)</a>. So its basically just <code class="language-plaintext highlighter-rouge">int a = 260 - 4</code>.
<code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>While de4dot will simplify <code class="language-plaintext highlighter-rouge">int a = 260 - 4</code> to <code class="language-plaintext highlighter-rouge">int a = 256</code> it will not simplify the expression containing <code class="language-plaintext highlighter-rouge">sizeof(int)</code> so to fix this we will need to get rid of the sizeof.</p>

<p>To understand how we can remove the sizeof from our expression we will first need to take a look at the CIL Code of our expression.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldc.i4 260
sizeof System.Integer
sub
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ldc.i4</code> OpCode with the operand value of 260 initializes an integer with said value.</li>
  <li><code class="language-plaintext highlighter-rouge">sizeof</code> OpCode with the operand System.Integer represents <code class="language-plaintext highlighter-rouge">sizeof(int)</code> which will result in a integer value of 4.</li>
  <li><code class="language-plaintext highlighter-rouge">sub</code> OpCode stands for subract (-).</li>
</ul>

<p><br />
To get rid of the sizeof we will resolve its resulting integer value and replace the sizeof OpCode with an integer <em>(ldc.i4 OpCode)</em>. I will explain the concept below:</p>

<ol>
  <li>Get all Types and their methods</li>
  <li>Foreach method that has a CILBody check if the instructions contain sizeof OpCode(s)</li>
  <li>For every found sizeof OpCode call <code class="language-plaintext highlighter-rouge">GetImpliedMemoryLayout(is32Bit true/false)</code>¹ <em>(feature of AsmResolver)</em> If you dont use AsmResolver you can run a dynamic method that calls <code class="language-plaintext highlighter-rouge">sizeof(T)</code>. T being the the operand type of the sizeof OpCode².</li>
  <li>Replace the sizeof OpCode with an ldc.i4 OpCode and set its operand to the value thats returned by GetImpliedMemoryLayout.</li>
  <li>Call OptimizeMacros() to optimize CIL like <code class="language-plaintext highlighter-rouge">ldc.i4 1</code> to <code class="language-plaintext highlighter-rouge">ldc.i4.1</code></li>
</ol>

<p>My full code can be found <a href="https://github.com/dr4k0nia/Unscrambler/blob/master/Unscrambler/Features/MethodFeatures/SizeOfReplace.cs">here</a></p>

<p><em><font size="2"> 1. This assumes that you have before determined if the code is 32bit or not. If the code is 32bit call the method with the parameter true else use false.</font></em>
<br />
<em><font size="2"> 2. This requires reflection while AsmResolvers method is completely static. </font></em></p>

<h2 id="21-deconstructing-locals-to-fields">2.1 Deconstructing: Locals to Fields</h2>

<p>Another example found in numerous forks of ConfuserEx is the locals to fields protection it basically does what the name says it converts locals to field. Since de4dot will not simplify expressions that include field values we want to restore the fields back to locals.</p>

<p>The examples I have found during my research mostly work somewhat like this:</p>

<ul>
  <li>OpCodes like stloc, ldloc and ldloca are replaced with their field equivalents stsfld, ldsfld, ldsflda<code class="language-plaintext highlighter-rouge">&lt;br&gt;</code></li>
  <li>The replacement fields are created in the global type¹, <code class="language-plaintext highlighter-rouge">&lt;Module&gt;</code> by default. These fields will have the attributes: public and static.<code class="language-plaintext highlighter-rouge">&lt;br&gt;</code></li>
  <li>(Optional) Sometimes one field is used to replace multiple locals of the same type, for example all locals of the type int are replaced with the same field.</li>
</ul>

<p><em><font size="2"> 1. The fields could also be created in any other public type, but all forks I looked at used the global type. </font></em></p>

<p>Lets say the original code looks like this</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">text</span> <span class="p">=</span> <span class="nf">SomeMethodThatReturnsAString</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After running it through an obfuscator using locals 2 fields we will receive something like this. Instead of to a local the string returned by <code class="language-plaintext highlighter-rouge">SomeMethodThatReturnsAString()</code> is now assigned to a field thats intialized in the global type.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">Module</span><span class="p">&gt;.</span><span class="n">Field0</span> <span class="p">=</span> <span class="nf">SomeMethodThatReturnsAString</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(&lt;</span><span class="n">Module</span><span class="p">&gt;.</span><span class="n">Field0</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(&lt;</span><span class="n">Module</span><span class="p">&gt;.</span><span class="n">Field0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking at the IL of the above shown code shows how minor these changes actually are. First we will look at the CIL Code of our original code. <em>(code is simplified)</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call string C::SomeMethodThatReturnsAString()
stloc.0
ldloc.0 
callvirt instance string [mscorlib]System.String::get_Length()
ldc.i4.0
...
ldloc.0
call void [System.Console]System.Console::WriteLine(string)
...
</code></pre></div></div>

<p>If we compare this to the obfuscated CIL Code it looks very similar. The OpCodes that set and load our locals value have been replaced with their field equivalents.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call string C::SomeMethodThatReturnsAString()
stsfld string &lt;Module&gt;::Field0
ldsfld string &lt;Module&gt;::Field0
callvirt instance int32 [System.Private.CoreLib]System.String::get_Length()
ldc.i4.0
...
ldsfld string &lt;Module&gt;::Field0
call void [System.Console]System.Console::WriteLine(string)
...
</code></pre></div></div>

<p>So to convert the fields back to locals we will do the following:</p>

<ol>
  <li>Search for fields that match the criteria (!private and static, has no default value, only used in one method) in the global type</li>
  <li>Check all method bodies for OpCodes were the operandtype is InlineField and the operand is a FieldDefinition</li>
  <li>Check if the matched FieldDefinition is one of the fields that we gathered from the global type:
    <ul>
      <li>if true: Add new local with the same type as the fields type, change all calls to the matched field with the newly created local. Store the replaced field and new local in a dictionary. Check if there is already a local for the matched field. If there is already an entry for the field use the entry from the dictionary.</li>
      <li>if false: skip</li>
    </ul>
  </li>
  <li>(Optional) Call OptimizeMacros()</li>
  <li>(Optional) Remove all fields that were replaced. In my case the ones from the before used dictionary.</li>
</ol>

<p>My full code can be found <a href="https://github.com/dr4k0nia/Unscrambler/blob/master/Unscrambler/Features/LocalsToFieldRemover.cs">here</a></p>

<h2 id="22-deconstructing-math-mutations">2.2 Deconstructing: Math Mutations</h2>

<p>Another protection that can be seen quite often in modified ConfuserEx versions, or standalone obfuscators. Are math mutations, using System.Math methods like <code class="language-plaintext highlighter-rouge">Floor()</code> and <code class="language-plaintext highlighter-rouge">Ceiling()</code> to generate expressions or replace simple integers.</p>

<p>We will start with the original code again:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">256</span><span class="p">;</span>
</code></pre></div></div>

<p>Now the obfuscated one. As you can see its quite hard to guess the original number of our integer now.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="m">102402.0</span><span class="p">)</span> <span class="p">-</span> <span class="m">102146</span><span class="p">;</span>
</code></pre></div></div>

<p>What the obfuscator has done is create an expression that will result in our original integer. I will not go in to the details of how that is achieved as it is not that important for unpacking this protection. Lets look at the CIL Code of the obfuscated snippet.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldc.r8 102402
call float64 [System.Private.CoreLib]System.Math::Floor(float64)
conv.i4
ldc.i4 102146
sub
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ldc.r8</code> OpCode represents the parameter supplied to <code class="language-plaintext highlighter-rouge">Math.Floor()</code> its operand is the value</li>
  <li><code class="language-plaintext highlighter-rouge">call</code> OpCode will call <code class="language-plaintext highlighter-rouge">Math.Floor()</code> with the above supplied value</li>
  <li><code class="language-plaintext highlighter-rouge">conv.i4</code> OpCode casts the result of <code class="language-plaintext highlighter-rouge">Math.Floor()</code> to integer. Which is required since the second value of the expression is an integer (ldc.i4)</li>
  <li><code class="language-plaintext highlighter-rouge">ldc.i4</code> OpCode pushes an integer with the value of its operand onto the stack</li>
  <li><code class="language-plaintext highlighter-rouge">sub</code> OpCode stands for subtract (-)</li>
</ul>

<p>In order to make this fixable by de4dot we will need to get rid of the <code class="language-plaintext highlighter-rouge">Math.Floor()</code> so what we will do to archieve this is the following:</p>

<ol>
  <li>Check method bodies for instructions which operand is a MemberRef with the DeclaringTypes FullName equal to System.Math</li>
  <li>Use Reflection to resolve the method using the resolved MemberRefs MetadataToken (make sure to resolve it from the original System.Math class)¹</li>
  <li>Check the methods parameter count</li>
  <li>Get the parameters required from the instructions operands, and Nop the instructions. Implement a check that only includes constant types if the obtained params are not a constant type continue (skip further processing)</li>
  <li>Invoke the method with the paramters obtained before</li>
  <li>Replace the call instruction with the OpCode related to the return type of our math function in this case ldc.r8 and set its operand to the result returned by the invoked method</li>
</ol>

<blockquote>
  <ol>
    <li>This will fail if the target app uses a different framework, to do it properly we would have to resolve the target framework and use its math class. Fix will be added later</li>
  </ol>
</blockquote>

<p>My full code can be found <a href="https://github.com/dr4k0nia/Unscrambler/blob/master/Unscrambler/Features/MethodFeatures/MathReplace.cs">here</a></p>

<h2 id="23-deconstructing-calls-to-calli">2.3 Deconstructing: Calls to Calli</h2>

<p>Calls to Calli can be found in most ConfuserEx forks however the implementation thats commonly used is not very effective.</p>

<p>For this example we will skip looking at the C# Code and checkout the CIL Code instead. Lets start with the original code</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call void [System.Windows.Forms]System.Windows.Froms.Application::EnableVisualStyles()
</code></pre></div></div>

<p>If we look at the CIL Code produced by the calls to calli protection, we can see that the ldftn OpCodes operand is the same as the call OpCodes operand in the unobfuscated code, with a little thinking it is pretty obvious how simple the fix will be.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldftn void [System.Windows.Forms]System.Windows.Froms.Application::EnableVisualStyles()
calli void()
</code></pre></div></div>

<p>To get rid of the calli protection we will do the following:</p>

<ol>
  <li>Search method bodies for calli OpCodes that are lead by ldftn OpCodes</li>
  <li>Remove the calli OpCode and Change the ldftn OpCode to call</li>
</ol>

<p>My full code can be found <a href="https://github.com/dr4k0nia/Unscrambler/blob/master/Unscrambler/Features/MethodFeatures/CalliReplace.cs">here</a></p>

<h2 id="3-credits">3. Credits</h2>

<ul>
  <li><a href="https://github.com/anonymoosere">AnonymooseRE</a> For helping out with Unscrambler and answering a lot of my questions</li>
  <li><a href="https://github.com/Washi1337/AsmResolver">Washi</a> For AsmResolver and answering my questions</li>
  <li><a href="https://sharplab.io">sharplab.io</a> For their online compiler and IL view</li>
</ul>
:ET