I"™∏<p>After developing a runtime packer in the last post, I tinkered with anti dumping techniques using PE Header manipulation. In this post I will talk about different approaches and take a look at the commonly used dumper ExtremeDumper.</p>

<p><em><font size="2">*ConfuserEx AntiDump is not included in this article as it would be enough for an entire article</font></em></p>

<h2 id="what-is-a-memory-dump">What is a memory dump?</h2>
<p>A memory dump consists of the recorded state of the working memory of a computer program at a specific time. In our case this would be the state of the memory once an assembly is fully loaded.<br />
A memory dump is typically used to extract dynamically loaded assemblies or information that is decrypted at runtime. This article will focus on dumping tools that dump an entire .NET assembly at runtime.</p>

<h2 id="why-do-people-use-antidump">Why do people use AntiDump</h2>

<p>Trying to prevent people from dumping your process memory can have many reasons. The most obvious reason would be runtime decryption for example the method body encryption used by ConfuserEx which will only decrypt the CIL method bodies on runtime. Meaning the easiest way to restore the CIL bodies is by dumping the app with the decrypted method bodies from memory.
<br /> 
Another obvious target for dumping are runtime packers that decrypt and invoke their payload on runtime. Instead of reverse engineering often heavily obfuscated code, you can simply dump the payload from memory.</p>

<h2 id="preventing-a-memory-dump">Preventing a memory dump</h2>

<h3 id="process-names">Process names</h3>

<p>In order to prevent a memory dump we can do a few things. The simplest solution you have probably seen many times, is checking for process names. If a known dumper process is found the app will trigger some action. However, this technique is quite trivial to bypass as one can simply rename their dumper. Not to mention a list of bad process names is an obvious flag for any reverse engineer. Another downside is the need to constantly monitor running processes.</p>

<h3 id="erasing-pe-header-data">Erasing PE Header data</h3>

<p>Another commonly used anti dumping solution I have seen many times is erasing certain fields in the PE Header. Unlike native apps we cannot just erase the entire PE Header since it is used by the .NET CLR after initialization. Lets look into one of the most common classes used for erasing PE Header information.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AntiDump</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">process</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Process</span><span class="p">.</span><span class="nf">GetCurrentProcess</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">base_address</span> <span class="p">=</span> <span class="n">process</span><span class="p">.</span><span class="n">MainModule</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">;</span>
  <span class="kt">var</span> <span class="n">dwpeheader</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">InteropServices</span><span class="p">.</span><span class="n">Marshal</span><span class="p">.</span><span class="nf">ReadInt32</span><span class="p">((</span><span class="n">IntPtr</span><span class="p">)(</span><span class="n">base_address</span><span class="p">.</span><span class="nf">ToInt32</span><span class="p">()</span> <span class="p">+</span> <span class="m">0x3C</span><span class="p">));</span>
  <span class="kt">var</span> <span class="n">wnumberofsections</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">InteropServices</span><span class="p">.</span><span class="n">Marshal</span><span class="p">.</span><span class="nf">ReadInt16</span><span class="p">((</span><span class="n">IntPtr</span><span class="p">)(</span><span class="n">base_address</span><span class="p">.</span><span class="nf">ToInt32</span><span class="p">()</span> <span class="p">+</span> <span class="n">dwpeheader</span> <span class="p">+</span> <span class="m">0x6</span><span class="p">));</span>

  <span class="nf">EraseSection</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="m">30</span><span class="p">);</span>
  <span class="p">...</span>
</code></pre></div></div>

<p><em>Code by Mecanik, from <a href="https://github.com/Mecanik/Anti-DebugNET/blob/master/Anti-DebugNET/AntiDump/DumpProtect1.cs">here</a></em></p>

<p>First of all, we get the current process and the <code class="language-plaintext highlighter-rouge">BaseAddress</code> of its <code class="language-plaintext highlighter-rouge">MainModule</code>. The <code class="language-plaintext highlighter-rouge">BaseAddress</code> is the beginning of the current module‚Äôs PE Header. We continue by reading the value of <code class="language-plaintext highlighter-rouge">e_lfanew</code>, a field located in the DOS Header which contains the offset to the beginning of the File Header. The value is stored in the local variable <code class="language-plaintext highlighter-rouge">dwpeheader</code>. Next, we read <code class="language-plaintext highlighter-rouge">NumberOfSections</code> from the File Header. To obtain its address the value of <code class="language-plaintext highlighter-rouge">dwpeheader</code> and an offset of <code class="language-plaintext highlighter-rouge">0x6</code> is added to the <code class="language-plaintext highlighter-rouge">BaseAddress</code>.</p>

<p>Next off, <code class="language-plaintext highlighter-rouge">EraseSection</code> is called with the <code class="language-plaintext highlighter-rouge">BaseAddress</code> and <code class="language-plaintext highlighter-rouge">30</code> supplied as parameters. It overwrites the specified amount of bytes at the given address with zero bytes using the functions <code class="language-plaintext highlighter-rouge">VirtualProtect</code> and <code class="language-plaintext highlighter-rouge">ZeroMemory</code> exported by kernel32.dll.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="n">IntPtr</span> <span class="nf">ZeroMemory</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">size</span><span class="p">);</span>

<span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="n">IntPtr</span> <span class="nf">VirtualProtect</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">lpAddress</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">dwSize</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">flNewProtect</span><span class="p">,</span> <span class="k">ref</span> <span class="n">IntPtr</span> <span class="n">lpflOldProtect</span><span class="p">);</span>

<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">EraseSection</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">IntPtr</span> <span class="n">sz</span> <span class="p">=</span> <span class="p">(</span><span class="n">IntPtr</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">IntPtr</span> <span class="n">dwOld</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">IntPtr</span><span class="p">);</span>
  <span class="nf">VirtualProtect</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="p">(</span><span class="n">IntPtr</span><span class="p">)</span> <span class="m">0x40</span><span class="p">,</span> <span class="k">ref</span> <span class="n">dwOld</span><span class="p">);</span>
  <span class="nf">ZeroMemory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
  <span class="n">IntPtr</span> <span class="n">temp</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">IntPtr</span><span class="p">);</span>
  <span class="nf">VirtualProtect</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">dwOld</span><span class="p">,</span> <span class="k">ref</span> <span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs take a closer look at <code class="language-plaintext highlighter-rouge">EraseSection</code>. Initially <code class="language-plaintext highlighter-rouge">VirtualProtect</code> is called to set the protection for the desired memory region to <code class="language-plaintext highlighter-rouge">PAGE_EXECUTE_READWRITE</code>(<code class="language-plaintext highlighter-rouge">0x40</code>). Which enables read, write, and execution permissions for that region. Next, <code class="language-plaintext highlighter-rouge">ZeroMemory</code> is called on the before unprotected region, which will overwrite the specified region size with zero bytes. Finally, the protection of the region is restored to the previous protection by calling <code class="language-plaintext highlighter-rouge">VirtualProtect</code> again but with the old protection as the <code class="language-plaintext highlighter-rouge">flNewProtect</code> argument.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">peheaderdwords</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
  <span class="nf">EraseSection</span><span class="p">((</span><span class="n">IntPtr</span><span class="p">)(</span><span class="n">base_address</span><span class="p">.</span><span class="nf">ToInt32</span><span class="p">()</span> <span class="p">+</span> <span class="n">dwpeheader</span> <span class="p">+</span> <span class="n">peheaderwords</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="m">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The code continues with erasing some specific fields in the File Header, Optional Header, and the Section Table using multiple arrays of hardcoded offsets. This is done using multiple loops which iterate trough the arrays containing the offsets. For every offset it calls <code class="language-plaintext highlighter-rouge">EraseSection</code> using the following address chain: <code class="language-plaintext highlighter-rouge">base_address</code> + <code class="language-plaintext highlighter-rouge">dwpeheader</code> + the array value at index <code class="language-plaintext highlighter-rouge">i</code>.</p>

<p>I will not go over that part in too much detail, however I wrote a simple tool to map the offsets used in the code to their corresponding fields in the PE Header. The tool and a list of all the mapped fields can be found <a href="https://gist.github.com/dr4k0nia/682cb6db231516b904c166226e5e5676">here</a>, code is commented so you can follow the process.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x20 offset to Section_Linenumbers_Number in the Section Table =&gt; location: 0000019A
0x8 offset to Unknown in the Section Table =&gt; location: 00000182
0xC offset to Unknown in the Section Table =&gt; location: 00000186
0x10 offset to Unknown in the Section Table =&gt; location: 0000018A
0x14 offset to Unknown in the Section Table =&gt; location: 0000018E
0x18 offset to Unknown in the Section Table =&gt; location: 00000192
0x1C offset to Unknown in the Section Table =&gt; location: 00000196
0x24 offset to Unknown in the Section Table =&gt; location: 0000019E
</code></pre></div></div>

<p>If you check the full list you will notice a few fields mapped to Unknown, these are offsets that point to somewhere inside the Section Table however they seem to be incorrect as they don‚Äôt point to a specific field but only at data in between 2 fields. Take a close look at the locations shown in the above segement of the mappers output and compare them to the actual field offsets taken from CFF explorer.</p>

<p><img src="/images/cff_sections.png" alt="CFF sections example" /></p>

<p>You will see that the locations resolved by the mapper dont match with any of the field offsets that CFF Explorer shows. Instead they seem to be off by two, for example the first offset in the sectiontablewords array <code class="language-plaintext highlighter-rouge">0x8</code> results in the location <code class="language-plaintext highlighter-rouge">00000182</code> which is plus two off from <code class="language-plaintext highlighter-rouge">Virtual Size</code> and minus two off from <code class="language-plaintext highlighter-rouge">Virtual Address</code>. This might be intentional but I cannot make any sense of it.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;=</span> <span class="n">wnumberofsections</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">EraseSection</span><span class="p">((</span><span class="n">IntPtr</span><span class="p">)((</span><span class="n">base_address</span><span class="p">.</span><span class="nf">ToInt32</span><span class="p">()</span> <span class="p">+</span> <span class="n">dwpeheader</span> <span class="p">+</span> <span class="m">0xFA</span> <span class="p">+</span> <span class="p">(</span><span class="m">0x28</span> <span class="p">*</span> <span class="n">x</span><span class="p">))</span> <span class="p">+</span> <span class="m">0x20</span><span class="p">),</span> <span class="m">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">EraseSection</span><span class="p">((</span><span class="n">IntPtr</span><span class="p">)((</span><span class="n">base_address</span><span class="p">.</span><span class="nf">ToInt32</span><span class="p">()</span> <span class="p">+</span> <span class="n">dwpeheader</span> <span class="p">+</span> <span class="m">0xFA</span> <span class="p">+</span> <span class="p">(</span><span class="m">0x28</span> <span class="p">*</span> <span class="n">x</span><span class="p">))</span> <span class="p">+</span> <span class="n">sectiontabledwords</span><span class="p">[</span><span class="n">y</span><span class="p">]),</span> <span class="m">4</span><span class="p">);</span>

  <span class="n">y</span><span class="p">++;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="p">==</span> <span class="n">sectiontabledwords</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">++;</span>
    <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This part contains the offsets that I assume to be invalid. The loop iterates through all sections and erases certain fields using an array of offsets and one hardcoded offset. However only the hardcoded offset <code class="language-plaintext highlighter-rouge">0x20</code> seems to be correct, it resolves to Linenumbers Number. The other offsets point to data in between fields as previously mentioned.</p>

<h4 id="some-comments-on-the-code">Some comments on the code</h4>

<p>Importing native functions like <code class="language-plaintext highlighter-rouge">ZeroMemory</code> and <code class="language-plaintext highlighter-rouge">VirtualProtect</code> is a pretty big hint for reverse engineers, that there will likely be some kind of data manipulation or memory manipulation going on. Native imports are also quite easy to spot even when obfuscated, due to the DllImport attribute containing the dll‚Äôs name aswell as the EntryPoint which is the name of the function that is imported. This however is the case for basically every AntiDump that relies on PE Header manipulation, since by default the memory region of the PE Header is marked read-only. To change this and enable write permissions it is hard to circumvent calling either <code class="language-plaintext highlighter-rouge">VirtualProtect</code> or <code class="language-plaintext highlighter-rouge">VirtualProtectEx</code>*. 
<br />
Coming back to this specific implementation, the way <code class="language-plaintext highlighter-rouge">VirtualProtect</code> is used here is highly inefficient, as it is called for every offset in the array while all offsets are in a certain range within the PE Header. Since the offsets of the fields that are being erased are known one could simply change the memory protection for the entire range until the biggest offset. Changing the protection once for this range and then restoring it after completing all overwrites would be a lot more efficent. Additionaly I would utilize <code class="language-plaintext highlighter-rouge">0x04</code> (READ_WRITE) for memory protection as thats sufficent for overwriting/erasing values. Another point I would critique: A lot of the fields being erased are zero by default, so overwriting them seems pointless. The biggest issue in my opinion: All offsets are hardcoded for PE32 which means the code only works on 32bit applications.</p>

<p><em><font size="2">*You can also use NtProtectVirtualMemory but its undocumented and does not offer any particular benefit over normal VirtualProtect.</font></em></p>

<h3 id="modifying-the-pe-header">Modifying the PE Header</h3>

<p>Instead of simply erasing data from the PE Header why not change a few values to break common dumpers. To understand what we need to modify we will take a quick look into how dumpers like ExtremeDumper parse the image in memory.</p>

<p>In order to dump the image in memory ExtremeDumper will parse the PE Header. The PE Header contains important information about the structure of the file. This includes the virtual addresses of the sections, the machine type and import address table. The structure of the header is mostly the same everytime it starts with the DOS Header which is 60 bytes in size. The DOS Header does not contain much information apart from the offset to the File Header and the PE signature <code class="language-plaintext highlighter-rouge">MZ</code> (also called PE Magic). You can erase the entire DOS Header from memory on runtime and your app will run just fine, since the PE Loader and CLR only require the DOS Header for initialization.
<br /> 
The File Header that follows the DOS Header however is a bit more important, it contains information like the number of sections and the size of the Optional Header. These two values are actually the most important ones for further processing. 
<br />
ExtremeDumper, or rather dnlib which is used to parse the PE Header, requires the value of <code class="language-plaintext highlighter-rouge">SizeOfOptionalHeader</code> to correctly parse the Optional Header and calculate the correct image size. After some testing it turned out that changing the value of <code class="language-plaintext highlighter-rouge">SizeOfOptionalHeader</code> only works for x64 compiled binaries and only with <code class="language-plaintext highlighter-rouge">short.MaxValue</code>. I could not find the exact reason for this behavior but it seems like x64 binaries are loaded differently by the CLR compared to x86 binaries.</p>

<p>While checking the DOS Header parser of dnlib I noticed that simply changing the PE Signature, or erasing it, is enough to abort parsing by dnlib. Which means we could just replace the DOS Headers PE Signature with something else for example the signature for a ZIP file. It will look like a valid header in memory instead of being a block of zero bytes followed by the File Header.</p>

<p>The example uses a 32bit C# console application.</p>

<p><img src="/images/original_header.png" alt="original header" />
<br />
This is a dump of the original PE Header notice the PE Signature <code class="language-plaintext highlighter-rouge">MZ</code> <br />or as dnlib reads it <code class="language-plaintext highlighter-rouge">0x5A4D</code></p>

<p><img src="/images/modified_header.png" alt="modified header" />
<br />
This is a dump of my modified PE Header notice the Signature changed to <code class="language-plaintext highlighter-rouge">PK</code> which is actually for ZIP files. Dnlib would in this case read <code class="language-plaintext highlighter-rouge">0x4B50</code> as the Signature and abort further parsing.</p>

<p>While changing values in the PE header is quite successful for many dumpers, some dumpers are actually able to deal with it just fine. One problem with PE Header manipulation is that we only modify the image in memory but not the image on disk. Many dumpers have features that compare the two versions of the image and can thereby fix some overwritten values. In the next section I will go into the different approaches one could take to counter runtime PE Header manipulation.</p>

<p>An example implementation of the above described can be found <a href="https://gist.github.com/dr4k0nia/ae7c4dff6a03857457011c1bb35e7bef">here</a></p>

<p><em>Code references:</em><br />
<em><a href="https://github.com/wwh1004/ExtremeDumper/blob/490418d9a3372ebe30bea6e989cf7e0d287b393a/ExtremeDumper/Dumping/NormalDumper.cs#L112">ExtremeDumper NormalDumper.cs</a></em> |
<em><a href="https://github.com/0xd4d/dnlib/blob/634db70a06aeb152bc06c46b07561350699b0c85/src/PE/PEInfo.cs#L45">dnlib PEInfo.cs</a></em> |
<em><a href="https://github.com/0xd4d/dnlib/blob/634db70a06aeb152bc06c46b07561350699b0c85/src/PE/ImageDosHeader.cs#L26">dnlib ImageDosHeader.cs</a></em></p>

<h2 id="countering-antidump-protections">Countering AntiDump protections</h2>

<h4 id="using-the-disk-image">Using the disk image</h4>

<p>As you might have noticed most of the above mentioned protection schemes rely on PE Header manipulation on runtime, meaning the PE Header on disk is almost always completely fine. A simple way to mitigate erased PE Header info is just comparing the dump to the disk image and fixing unusual or missing data.  You can even do that on runtime parsing both disk image and memory image checking them against each other. If we find anomalies, such as an invalid value for <code class="language-plaintext highlighter-rouge">SizeOfOptionalHeader</code>, we can compare those invalid values with the original data from the disk image and then replace them if necessary. Another solution is checking redundant fields of the PE Header for example we could check if the machine type adds up with the size of the Optional Header. The Optional Headers size will by default always be the same for x64 and x86. So checking the machine type can give us a hint for the correct size even if it was changed. Many more complex AntiDumps techniques will also erase .NET metadata. In that case using the disk image for comparison is again a great way to fix the issue.</p>

<h4 id="patching-the-binary">Patching the binary</h4>

<p>What you can also easily do most of the time, is removing the AntiDump method from the binary or if that is not possible, hook it using Harmony for example. How exactly the hook looks like is not that important as there are many different ways to patch the AntiDump. When looking for AntiDump methods in virtualized code or heavily obfuscated code you can almost always rely on the required usage of <code class="language-plaintext highlighter-rouge">VirtualProtect</code> or any other memory protection function. This means that by using either a Debugger or a API monitoring tool we can find the code region that calls <code class="language-plaintext highlighter-rouge">VirtualProtect</code> and patch it or hook it. However this requires knowledge of assembly code.</p>

<h2 id="bonus-hiding-pinvoke-methods">Bonus: ‚ÄúHiding‚Äù P/Invoke methods</h2>

<p>One big issue with many AntiDumps is that they need to use P/Invoke to import native functions, which is easy to spot for reverse enginners. What can you do to obscure or hide the imports of native functions? Let us have a look at a couple of methods to hide the imported functions.</p>

<h3 id="dynamic-invoking">Dynamic invoking</h3>

<p>For this we will dynamically resolve a functions address using <code class="language-plaintext highlighter-rouge">GetProcAddress</code>. The disadvantage of this method is obviously that we still have to use a P/Invoke method, however we can obfuscate the name of the actual function we want to call.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">,</span> <span class="n">CharSet</span> <span class="p">=</span> <span class="n">CharSet</span><span class="p">.</span><span class="n">Ansi</span><span class="p">,</span> <span class="n">ExactSpelling</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="n">SetLastError</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="n">IntPtr</span> <span class="nf">GetProcAddress</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">hModule</span><span class="p">,</span> <span class="kt">string</span> <span class="n">procName</span><span class="p">);</span>

<span class="p">[</span><span class="nf">UnmanagedFunctionPointer</span><span class="p">(</span><span class="n">CallingConvention</span><span class="p">.</span><span class="n">StdCall</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">delegate</span> <span class="kt">uint</span> <span class="nf">PVM</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">ProcessHandle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">IntPtr</span> <span class="n">BaseAddress</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">uint</span> <span class="n">numberOfBytes</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">newProtect</span><span class="p">,</span> <span class="k">out</span> <span class="kt">uint</span> <span class="n">oldProtect</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">IntPtr</span> <span class="nf">GetLoadedModuleAddress</span><span class="p">(</span><span class="kt">string</span> <span class="n">dllName</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">procModules</span> <span class="p">=</span> <span class="n">Process</span><span class="p">.</span><span class="nf">GetCurrentProcess</span><span class="p">().</span><span class="n">Modules</span><span class="p">;</span>
  <span class="k">foreach</span><span class="p">(</span><span class="n">ProcessModule</span> <span class="n">mod</span> <span class="k">in</span> <span class="n">procModules</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">.</span><span class="n">ModuleName</span> <span class="p">!=</span> <span class="n">dllName</span><span class="p">)</span> 
        <span class="k">continue</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">mod</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">IntPtr</span> <span class="nf">GetFunctionPointer</span><span class="p">(</span><span class="kt">string</span> <span class="n">dllName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">functionName</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">hModule</span> <span class="p">=</span> <span class="nf">GetLoadedModuleAddress</span><span class="p">(</span><span class="n">dllName</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">GetProcAddress</span><span class="p">(</span><span class="n">hModule</span><span class="p">,</span> <span class="n">functionName</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First we import <code class="language-plaintext highlighter-rouge">GetProcAddress</code> from kernel32.dll using DllImport. Next we define a delegate with the <code class="language-plaintext highlighter-rouge">UnmanagedFunctionPointer</code> attribute since we will cast a native function pointer to this delegate later. The delegate <code class="language-plaintext highlighter-rouge">PVM</code> is for <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code> from ntdll.dll which is the underlying function of <code class="language-plaintext highlighter-rouge">VirtualProtect</code>. The <code class="language-plaintext highlighter-rouge">GetLoadedModuleAddress</code> function will get the base address of the specified <code class="language-plaintext highlighter-rouge">ProcessModule</code> from the current process. The most important function <code class="language-plaintext highlighter-rouge">GetFunctionPointer</code> gets the native function pointer of the specified function from the specified dll. Im using this method instead of <code class="language-plaintext highlighter-rouge">GetModuleHandle</code> to avoid further native imports.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Protect</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="n">dllName</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">Convert</span><span class="p">.</span><span class="nf">FromBase64String</span><span class="p">(</span><span class="s">"bnRkbGwuZGxs"</span><span class="p">));</span> <span class="c1">// ntdll.dll</span>
  <span class="kt">string</span> <span class="n">functionName</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">Convert</span><span class="p">.</span><span class="nf">FromBase64String</span><span class="p">(</span><span class="s">"TnRQcm90ZWN0VmlydHVhbE1lbW9yeQ=="</span><span class="p">));</span> <span class="c1">// NtProtectVirtualMemory</span>
  <span class="kt">var</span> <span class="n">fPointer</span> <span class="p">=</span> <span class="nf">GetFunctionPointer</span><span class="p">(</span><span class="n">dllName</span><span class="p">,</span> <span class="n">functionName</span><span class="p">);</span>
  <span class="n">PVM</span> <span class="n">pvm</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="n">GetDelegateForFunctionPointer</span><span class="p">&lt;</span><span class="n">PVM</span><span class="p">&gt;(</span><span class="n">fPointer</span><span class="p">);</span>

  <span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="n">Process</span><span class="p">.</span><span class="nf">GetCurrentProcess</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">@base</span> <span class="p">=</span> <span class="n">p</span><span class="p">.</span><span class="n">MainModule</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">;</span>

  <span class="kt">uint</span> <span class="n">size</span> <span class="p">=</span> <span class="m">0x3C</span><span class="p">;</span>

  <span class="nf">pvm</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">@base</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">,</span> <span class="m">0x04</span><span class="p">,</span> <span class="k">out</span> <span class="kt">uint</span> <span class="n">oldProtect</span><span class="p">);</span>

  <span class="n">Marshal</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="m">0</span><span class="p">,</span> <span class="n">@base</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>

  <span class="nf">pvm</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">@base</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">,</span> <span class="n">oldProtect</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs look into the actual protection code. First we specifiy the <code class="language-plaintext highlighter-rouge">dllName</code> and <code class="language-plaintext highlighter-rouge">functionName</code> parameters for <code class="language-plaintext highlighter-rouge">GetFunctionPointer</code>. I use simple Base64 Encoding in this example but you can use any kind of string encryption or encoding to obfuscate the names. Next we call <code class="language-plaintext highlighter-rouge">GetFunctionPointer</code> with the supplied names to obtain the address of our desired function. In this situation, I resolve the address to <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code> in ntdll.dll. We assign the delegate by casting the obtained address to a delegate using <code class="language-plaintext highlighter-rouge">Marshal.GetDelegateForFunctionPointer&lt;T&gt;</code>.</p>

<p>After assigning the delegate we get the current process and obtain the base address of its main module. Using the base address and a handle to our current process we call the <code class="language-plaintext highlighter-rouge">pvm</code> delegate to change the memory protection of the first 60 bytes (size of the DOS Header) of our module to 0x04 (READWRITE). We then copy an array of zero bytes to the location of the DOS Header thereby overwriting it entirely with zero bytes. Last we restore the memory protection of the DOS Header back to the old protection.</p>

<p>This might not be the best way of hiding native imports but it is better than simply exposing them without any kind of obfuscation.</p>

<p><em>The used example code can be found <a href="https://gist.github.com/dr4k0nia/ca72c5ddef2b5072831026aeeb9806fd">here</a></em></p>

<h3 id="syscalls">Syscalls</h3>

<p>This will implement direct syscalls completely avoiding exposing the funtion name or its dll name. It will also bypass basic usermode hooks on the functions we are syscalling. Disadvantages of this method are that it relies on native shellcode and we can only call functions that exist as a syscall.</p>

<p>In order to do a syscall we need to look at the function we are trying to syscall in my case <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code> also known as <code class="language-plaintext highlighter-rouge">ZwProtectVirtualMemory</code>.
Lets check the function in IDA to see how the syscall is implemented.</p>

<p><img src="/images/ntpvmpng.png" alt="NtProtectVirtualMemory dissassembly" />
<br />
<em><font size="2">64bit version of ntdll.dll</font></em></p>

<p>The index of the syscall in this case <code class="language-plaintext highlighter-rouge">0x50</code> (50h) is pushed into eax. The syscall instruction will use the index in eax to resolve the function its supposed to call.</p>

<p>Since C# does not support inline assembly, we  will need to create shellcode to syscall from our managed app.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov r10, rcx
mov eax, 0x50
syscall
ret
</code></pre></div></div>

<p>Basically we just copy the function dissassembly from IDA but remove the test and jnz instruction. This pattern is pretty much the same for every syscall except the index thats pushed into eax. <em>(This shellcode only works for 64bit apps)</em></p>

<p>Lets implement this in C#. We will need to import kernel32.dll <code class="language-plaintext highlighter-rouge">VirtualProtect</code>. And just as in the dynamic invoke example we need a delegate for <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code>. 
<br />
<em>(You could combine this with the native invoke to hide the VirtualProtect import)</em></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="n">PVM</span> <span class="n">pvm</span><span class="p">;</span>

<span class="k">private</span> <span class="k">static</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">Shellcode</span> <span class="p">=</span> <span class="p">{</span>
    <span class="m">0x49</span><span class="p">,</span> <span class="m">0x89</span><span class="p">,</span> <span class="m">0xCA</span><span class="p">,</span> <span class="c1">// mov r10,rcx</span>
    <span class="m">0xB8</span><span class="p">,</span> <span class="m">0x50</span><span class="p">,</span> <span class="m">0x00</span><span class="p">,</span> <span class="m">0x00</span><span class="p">,</span> <span class="m">0x00</span><span class="p">,</span> <span class="c1">// mov eax, 0x50</span>
    <span class="m">0x0F</span><span class="p">,</span> <span class="m">0x05</span><span class="p">,</span> <span class="c1">// syscall</span>
    <span class="m">0xC3</span> <span class="c1">// ret</span>
<span class="p">};</span>

<span class="k">static</span> <span class="nf">Suscall</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">fixed</span><span class="p">(</span><span class="kt">byte</span><span class="p">*</span> <span class="n">ptr</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">Shellcode</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="nf">VirtualProtect</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="m">10</span><span class="p">,</span> <span class="m">0x40</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">Win32Exception</span><span class="p">();</span>

    <span class="n">pvm</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="n">GetDelegateForFunctionPointer</span><span class="p">&lt;</span><span class="n">PVM</span><span class="p">&gt;((</span><span class="n">IntPtr</span><span class="p">)</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above assembled shellcode is stored as raw bytes. The <code class="language-plaintext highlighter-rouge">Suscall</code> function is a static constructor to initialize the shellcode and cache the delegate. This process is pretty similar to the dynamic invoke example however instead of resolving the function pointer we allocate the shellcode in a fixed buffer and then cast it to our previously defined <code class="language-plaintext highlighter-rouge">PVM</code> delegate. The delegate will directly call the syscall just like <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code> does. Using this we don‚Äôt need to invoke the NT function anymore, thereby also preventing a debugger from just setting a breakpoint on the function.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Protect</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="n">Process</span><span class="p">.</span><span class="nf">GetCurrentProcess</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">@base</span> <span class="p">=</span> <span class="n">p</span><span class="p">.</span><span class="n">MainModule</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">;</span>

  <span class="kt">uint</span> <span class="n">size</span> <span class="p">=</span> <span class="m">0x3C</span><span class="p">;</span>

  <span class="nf">pvm</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">@base</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">,</span> <span class="m">0x04</span><span class="p">,</span> <span class="k">out</span> <span class="kt">uint</span> <span class="n">oldProtect</span><span class="p">);</span>

  <span class="n">Marshal</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="n">IntPtr</span><span class="p">)</span><span class="n">@base</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>

  <span class="nf">pvm</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">@base</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">,</span> <span class="n">oldProtect</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The protection implementation remains mostly the same as before, but we call the cached syscall delegate to directly execute the underlying functionality of <code class="language-plaintext highlighter-rouge">NtProtectVirtualMemory</code>. This implementations looks a lot cleaner since the only thing that statically exposes the called function is the syscall index. To further obfuscate this you could encrypt the array containing the shellcode, so its harder to analyze statically.</p>

<p>One issue with allocating shellcode and syscalling is that it might be picked up as malware by an antivirus due to the more and more common usage of syscalls in malware. To avoid shellcode usage you could implement this as a native method which would also eliminate the need to use <code class="language-plaintext highlighter-rouge">VirtualProtect</code>.</p>

<p><em>The code for this example can be found <a href="https://gist.github.com/dr4k0nia/5fa8eac1a98a3bb6e9efe73571409e12">here</a></em></p>

<h2 id="conlusion">Conlusion</h2>

<p>I think this write up goes to show that simple PE Header manipulation might not be the best way to prevent people from dumping your app. However more complex approaches that involve .NET metadata manipulation can be quite effective against low skill attackers as they will require a lot more effort and knowledge to fix.
<br />
I hope the bonus segment on hiding P/Invoke methods gave some good ideas on how to obscure/obfuscate native imports. As I think obscuring native imports could be an improvement for some people. If you have any questions regarding the contents of the write up feel free to contact me on discord: drakonia#1110.</p>

<h2 id="credits">Credits</h2>

<ul>
  <li><a href="https://jhalon.github.io/utilizing-syscalls-in-csharp-1/">Jack Halon - Utilizing syscalls in C#</a></li>
</ul>

:ET